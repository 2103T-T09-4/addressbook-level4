= Keith Fong - Project Portfolio
:site-section: AboutUs
:imagesDir: ../images
:stylesDir: ../stylesheets

== PROJECT: Car park Finder

---

== Overview

Car park finder is a desktop address book application to find HDB (Housing Development Board) car parks in Singapore.
It allows you to work with a *Command Line Interface (CLI)* to display a list of car parks with the convenience of simply typing.
If you *use the computer frequently* and *commute by driving*, you would find our application useful in helping you obtain various information about car parks.

== Summary of contributions

* *Major enhancement*: Modified the *find feature to search for partial words* and *ignore certain words*.
** What it does: Allows the user to search for partial instances of words without needed to type everything.
** Justification: This feature improves the product significantly because a user can type lesser and the app should provide the same data still.
** Highlights:  This enhancement affects the existing commands and commands to be added in the future. I also wrote extra code which allowed us to re-use in the future.
** Credits: _{mention here if you reused any code/ideas from elsewhere or if a third-party library is heavily used in the feature so that a reader can make a more accurate judgement of how much effort went into the feature}_

* *Minor enhancement*: pulled postal code information using coordinates data by querying an API to convert it to store in a file for quick loading.

* *Code contributed*:
[https://github.com/CS2103-AY1819S1-T09-4/main/blob/master/src/main/java/seedu/parking/commons/util/StringUtil.java[String Util]],
[https://github.com/CS2103-AY1819S1-T09-4/main/blob/master/src/main/java/seedu/parking/logic/commands/FindCommand.java[Find Command]],
[https://github.com/CS2103-AY1819S1-T09-4/main/blob/master/src/main/java/seedu/parking/logic/parser/FindCommandParser.java[Find Command Parser]],
[https://github.com/CS2103-AY1819S1-T09-4/main/blob/master/src/test/java/seedu/parking/commons/util/GsonUtilTest.java[Gson test]].


* *Other contributions*:
** Project management
*** Morphed the code from address book to car park.
https://github.com/CS2103-AY1819S1-T09-4/main/pull/1[#1],
https://github.com/CS2103-AY1819S1-T09-4/main/pull/5[#5]
*** Morphed the test cases from address book to car park.
https://github.com/CS2103-AY1819S1-T09-4/main/pull/15[#15],
https://github.com/CS2103-AY1819S1-T09-4/main/pull/25[#25]

** Enhancement of existing features:
*** Wrote additional test for existing features to increase coverage from 72% - 77% https://github.com/CS2103-AY1819S1-T09-4/main/pull/83[#83]

** Documentation:
*** Did cosmetics tweaks to existing contents of the User Guide:
(Pull requests:
https://github.com/CS2103-AY1819S1-T09-4/main/pull/34[#34],
https://github.com/CS2103-AY1819S1-T09-4/main/pull/36[#36],
https://github.com/CS2103-AY1819S1-T09-4/main/pull/60[#60],
https://github.com/CS2103-AY1819S1-T09-4/main/pull/74[#74],
https://github.com/CS2103-AY1819S1-T09-4/main/pull/76[#76])

** Community:
*** PRs reviewed (with non-trivial review comments):


== Contributions to the User Guide


|===
|_Given below are sections I contributed to the User Guide. They showcase my ability to write documentation targeting end-users._
|===

=== Finding car parks : `find`

Finds a list of available car parks. +
Format: `find KEYWORD [MORE_KEYWORDS]` or `f KEYWORD [MORE_KEYWORDS]`

****
* Common words are ignored, like blk and ave.
* Upper and lower case characters do not matter.
****

.Before using find command
image::findbefore.png[width="880"]
The figure above is a sample display of the application.


.After using find command
image::findafter.png[width="880"]
The figure above shows what happen after executing the `find` command.


Example(s):

* `find punggol`
* `f HG83`

=== Select car park : `select`

Select the car park you wish to go to. +
Format: `select INDEX` or `s INDEX`

****
* The index refers to the index number shown in the displayed car park list.
* The index *must be a positive integer* `1, 2, 3, ...`
****

.After using select command
image::select.png[width="880"]
The figure above is the outcome of the select command.

Example(s):

Selecting the 2nd car park in the list.

Step 1. `list`

Step 2. `select 2`

Selecting the 1st car park in the results of the `find` command.

Step 1. `find sengkang`

Step 2.  `s 1`


== Contributions to the Developer Guide

|===
|_Given below are sections I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project._
|===

=== Undo/Redo feature
==== Current Implementation

The undo/redo mechanism is facilitated by `VersionedCarparkFinder`.
It extends `CarparkFinder` with an undo/redo history, stored internally as an `carparkFinderStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedCarparkFinder#commit()` -- Saves the current car park finder state in its history.
* `VersionedCarparkFinder#undo()` -- Restores the previous car park finder state from its history.
* `VersionedCarparkFinder#redo()` -- Restores a previously undone car park finder state from its history.

These operations are exposed in the `Model` interface as `Model#commitCarparkFinder()`, `Model#undoCarparkFinder()` and `Model#redoCarparkFinder()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedCarparkFinder` will be initialized with the initial car park finder state, and the `currentStatePointer` pointing to that single car park finder state.

The following diagram showcases the state at the start of the program.

.State and the start of the program
image::UndoRedoActivityDiagramNew1.png[width="800"]

Step 2. The user executes `find sengkang` command to find list of car park which contain sengkang from the car park finder. The `find` command calls `Model#updateFilteredCarparkList()`, causing the modified state of the car park finder after the `find sengkang` command executes to be saved in the `carparkFinderStateList`, and the `currentStatePointer` is shifted to the newly inserted car park finder state.

The following diagram shows a new state is created after the command `find segkang` is ran.

.State after running find command
image::UndoRedoActivityDiagramNew2.png[width="800"]

Step 3. The user executes `clear` to clear all entries. The `clear` command also calls `Model#commitCarparkFinder()`, causing another modified car park finder state to be saved into the `carparkFinderStateList`.

The following diagram shows a new state is created after the command `clear` is ran.

.State after running find then clear command
image::UndoRedoActivityDiagramNew3.png[width="800"]

[NOTE]
If a command fails its execution, it will not call `Model#commitCarparkFinder()`, so the car park finder state will not be saved into the `carparkFinderStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoCarparkFinder()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous car park finder state, and restores the car park finder to that state.

The following diagram shows a new state is created after the command `undo` is ran. The state pointer is moved.

.How the undo feature works in a diagram
image::UndoRedoActivityDiagramNew4.png[width="800"]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial car park finder state, then there are no previous car park finder states to restore. The `undo` command uses `Model#canUndoCarparkFinder()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following *_sequence diagram_* shows how the undo operation works:

.Sequence diagram of Undo/Redo feature
image::Sequence Diagram - Undo.png[width="800"]

The `redo` command does the opposite -- it calls `Model#redoCarparkFinder()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the car park finder to that state.

[NOTE]
If the `currentStatePointer` is at index `carparkFinderStateList.size() - 1`, pointing to the latest car park finder state, then there are no undone car park finder states to restore. The `redo` command uses `Model#canRedoCarparkFinder()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the car park finder, such as `list`, will usually not call `Model#commitCarparkFinder()`, `Model#undoCarparkFinder()` or `Model#redoCarparkFinder()`. Thus, the `carparkFinderStateList` remains unchanged.

The follow diagram showcases what happen when a command that does not modify the state is used.

.As the command does nothing, the state is not changed, but a new state is introduced
image::UndoRedoActivityDiagramNew5.png[width="800"]

Step 6. The user executes `clear`, which calls `Model#commitCarparkFinder()`. Since the `currentStatePointer` is not pointing at the end of the `carparkFinderStateList`, all car park finder states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `find sengkang` command. This is the behavior that most modern desktop applications follow.

The following diagram showcases when a new command is used after an undo.

.Deleting a state diagram after an undo
image::UndoRedoActivityDiagramNew6.png[width="800"]

The following activity diagram summarizes what happens when a user executes a new command:

.Activity diagram of a sample command
image::General new command.png[width="650"]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire car park finder.

[cols="1,10"]
|===
|Pros| Easy to implement.
|Cons| May have performance issues in terms of memory usage.
|===


* **Alternative 2:** Individual command knows how to undo/redo by itself.

[cols="1,10"]
|===
|Pros| Will use less memory (e.g. for `select`, just save the car park being selected).
|Cons| We must ensure that the implementation of each individual command are correct.
|===

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of car park finder states.

[cols="1,10"]
|===
|Pros| Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
|Cons| Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedCarparkFinder`.
|===

* **Alternative 2:** Use `HistoryManager` for undo/redo

[cols="1,10"]
|===
|Pros| We do not need to maintain a separate list, and just reuse what is already in the codebase.
|Cons| Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
|===

// tag::dataencryption[]
=== [Proposed] Data Encryption

The car park data and user data will be encrypted to prevent users from editing and manipulating them.

==== Overview

The data encryption mechanism works by encrypting the information by a unique key generated by every users individual system.
The key will stored in a secured location to prevent people from accessing it.

The two main files it will encrypt are:

* Carpark information
* User's favorites

==== Example

_This feature is coming in v2.0._

// end::dataencryption[]

=== Find feature

The find feature searches for a car park by keyword or location.

==== Overview

The find mechanism is facilitated by `FindCommand` and `FindCommandParser`. It extends `Command` and implements the following operations:

* `FindCommand#execute()` -- Executes the command by running a predicate `CarparkContainsKeywordsPredicate` to update the car park list.

The find mechanism is supported by `FindCommandParser`. It implements `Parser` and contains the following operations:

* `FindCommandParser#parse()` -- Checks the arguments for empty strings and throws a `ParseException` if empty string is found. It then splits it by one or more white spaces. It then removes any strings in the list of common words.

The predicate `CarparkContainsKeywordsPredicate` takes in a list of strings and checks if any of the strings matches the name or address of a car park fully or partially.

.How the find operation works
image::seqdiagram-find.png[width="800", align="left"]

The diagram above describes how the flow of a find command would execute. It rely on `FindCommandParser` to ensure the variables are correct.

==== Example

Given below is an example usage scenario of how the Find mechanism behaves at each step.

Step 1. The user launches the application for the first time.

Step 2. The user executes `find punggol` command to get all car parks in punggol.
The `find` command calls `FindCommandParser#parse()`.

[NOTE]
If a command execution fails, it will not call `FindCommand#execute()`, and the car park finder state will not be saved.

Step 3. The entire list of car parks is filtered by the predicate `CarparkContainsKeywordsPredicate`, which checks for the keyword `punggol`.

Step 4. The filtered list of car parks is returned to the GUI.

The flow chart below describes the user interaction with the application and how it processes it.

.Flow chart of the find operation.
image::actdiagram-find.png[width="800", align="left"]

==== Design Considerations

===== Aspect: How predicate works

* **Alternative 1 (Current choice):** Predicate have additional filter with an ignore list.
+
[cols="1,10"]
|===
|Pros| Re-usable functions introduced for partial checking.
|Cons| Reading the car park list while querying might cause unintended side effects if not handled properly.
|===
+


* **Alternative 2:** Filter the data when it is taken in.
+
[cols="1,10"]
|===
|Pros| Easy to maintain as predicate will have lesser conditions.
|Cons| Breaks OOP style as the parser will modify the data.
|===
+




== PROJECT: PowerPointLabs

---

_{Optionally, you may include other projects in your portfolio.}_
